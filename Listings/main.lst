C51 COMPILER V9.54   MAIN                                                                  05/01/2019 11:03:53 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE DEBUG PRINT(.\Listings\main.l
                    -st) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <stc15w.h>
   2          #include <intrins.h>
   3          #include <stdio.h>
   4          #include <string.h>
   5          #include "STC_PWM.h"
   6          //#include  "T_SineTable.h"
   7          #include "AD.h" 
   8          
   9          
  10          
  11          
  12          #define CCP_S0 0x10                 //P_SW1.4
  13          #define CCP_S1 0x20                 //P_SW1.5
  14          //单片机内部寄存器
  15          #define S3RI  0x01              //S3CON.0
  16          #define S3TI  0x02              //S3CON.1
  17          
  18          
  19          sbit SP485_ON=P3^4;   //1: 发送    0:接收
  20          sbit Drive_SD=P0^4;   //1: 关闭    0:使能
  21          
  22          
  23          #define UART_BUF_LEN  32
  24          #define UART_BUF_MASK (UART_BUF_LEN - 1)
  25          u8 Uart3_Rec[UART_BUF_LEN]={0};
  26          u8 uartRcvLen = 0;
  27          u8 uartReadLen = 0;
  28          
  29          
  30          
  31          
  32          #define __debug   
  33          /************************************
  34            延时子程序
  35            延时时间(xms*1)ms
  36           *************************************/
  37          void delayms(u16 xms)
  38          {
  39   1          u16 x,y;
  40   1          for(x=xms;x>0;x--)
  41   1              for(y=550;y>0;y--);
  42   1      }
  43          void Uart1Init(void)    //9600bps@30.000MHz
  44          {
  45   1          SCON = 0x50;    //8位数据,可变波特率
  46   1          AUXR |= 0x40;   //定时器1时钟为Fosc,即1T
  47   1          AUXR &= 0xFE;   //串口1选择定时器1为波特率发生器
  48   1          TMOD &= 0x0F;   //设定定时器1为16位自动重装方式
  49   1          TL1 = 0xF3;   //设定定时初值
  50   1          TH1 = 0xFC;   //设定定时初值
  51   1          ET1 = 0;    //禁止定时器1中断
  52   1          TR1 = 1;    //启动定时器1
  53   1      }
  54          
C51 COMPILER V9.54   MAIN                                                                  05/01/2019 11:03:53 PAGE 2   

  55          void Uart3Init(void)    //9600bps@30.000MHz
  56          {
  57   1          S3CON = 0x10;   //8位数据,可变波特率
  58   1          S3CON |= 0x40;    //串口3选择定时器3为波特率发生器
  59   1          T4T3M |= 0x02;    //定时器3时钟为Fosc,即1T
  60   1          T3L = 0xF3;   //设定定时初值
  61   1          T3H = 0xFC;   //设定定时初值
  62   1          T4T3M |= 0x08;    //启动定时器3
  63   1          IE2 = 0x08;                 //使能串口3中断
  64   1          EA = 1;
  65   1      }
  66          void Timer0Init(void)   //10毫秒@30.000MHz
  67          {
  68   1          AUXR &= 0x7F;   //定时器时钟12T模式
  69   1          TMOD &= 0xF0;   //设置定时器模式
  70   1          TL0 = 0x58;   //设置定时初值
  71   1          TH0 = 0x9E;   //设置定时初值
  72   1          TF0 = 0;    //清除TF0标志
  73   1          TR0 = 1;    //定时器0开始计时
  74   1          ET0=1;
  75   1      }
  76          
  77          
  78          void SendData(u8 dat)
  79          {
  80   1          SBUF = dat;             //Send data to UART buffer
  81   1          while(!TI);
  82   1          TI=0;
  83   1      }
  84          
  85          /*----------------------------
  86            串口发送字符串
  87            ----------------------------*/
  88          void SendString(char *s)
  89          {
  90   1          while (*s)              //Check the end of the string
  91   1          {
  92   2              SendData(*s++);     //Send current char and increment string ptr
  93   2          }
  94   1      } 
  95          void IO_init()
  96          {
  97   1          P3M0 = 0xff;
  98   1          P3M1 = 0x00; // 配置 为输chu模式
  99   1          P0M0 = 0xff;
 100   1          P0M1 = 0x01; // 配置 为输chu模式  P00 P05 shuru  
 101   1          P4M0 = 0xff;
 102   1          P4M1 = 0x00; // 配置 为输chu模式
 103   1          P1M0 = 0xff;
 104   1          P1M1 = 0x03; // 配置 为输chu模式
 105   1      
 106   1          P2M0 = 0x00;
 107   1          P2M1 = 0x00;
 108   1      } 
 109          
 110          
 111          
 112          #define PROTECT_TIME   10
 113          u16 ptotectTimer = 200;
 114          void CurrentProtectTask(void)
 115          {
 116   1        if(!ptotectTimer)
C51 COMPILER V9.54   MAIN                                                                  05/01/2019 11:03:53 PAGE 3   

 117   1        {
 118   2          ptotectTimer = PROTECT_TIME;
 119   2          if( GetADCResult(1)>710)
 120   2          {
 121   3                  Drive_SD=1; //关闭IR2110芯片
 122   3          }
 123   2        }
 124   1      }
 125          
 126          
 127          u8 UartGetBuf(u8 *p)
 128          {
 129   1        u8 len = 0;
 130   1        while(uartRcvLen != uartReadLen)
 131   1        {
 132   2          p[len] = Uart3_Rec[uartReadLen];
 133   2          len++;
 134   2          uartReadLen++;
 135   2          delayms(20);
 136   2        }
 137   1        return len; 
 138   1      }
 139          void UartCmdProcess(void)
 140          {
 141   1        u8 buf[32];
 142   1        u8 temp[50];
 143   1        u16 freq;
 144   1        u16 volage;
 145   1        u8 len;
 146   1        len = UartGetBuf(buf);
 147   1        
 148   1        if(len) //接收到一组数据
 149   1        {
 150   2          freq=buf[2]; //获取频率
 151   2          volage=buf[7]<<8|buf[8]; //获取频率
 152   2          volage=volage/10;
 153   2          if(volage>28)
 154   2            volage=28;
 155   2          if(volage<1)
 156   2            volage=1;
 157   2                
 158   2          sprintf((char*)temp,"plv:%bu hz\r\n",freq);
 159   2          SendString(temp);
 160   2          sprintf((char*)temp,"Vol:%d\r\n",volage);
 161   2          SendString(temp);
 162   2          STC_PWM_SetVolage(freq,volage);
 163   2          Drive_SD=1; //关闭IR2110芯片
 164   2        }
 165   1      }
 166          void main(void)         
 167          {
 168   1          IO_init();
 169   1          Uart1Init();
 170   1          Uart3Init();
 171   1          Timer0Init();
 172   1          InitADC();        //Init ADC  
 173   1          SP485_ON=0;//使能485接收
 174   1          Drive_SD=1; //关闭IR2110芯片
 175   1          STC_PWM_Init(50);
 176   1          STC_PWM_SetVolage(50,20);
 177   1          while(1)            
 178   1          { 
C51 COMPILER V9.54   MAIN                                                                  05/01/2019 11:03:53 PAGE 4   

 179   2            UartCmdProcess();
 180   2          }   
 181   1      }
 182          //  d Timer0using using using using using using using 
 183          void Timer0() interrupt 1 using 1  //10ms
 184          {
 185   1        P35=~P35;
 186   1        CurrentProtectTask();
 187   1        STC_PWM_Timer();
 188   1      }
 189          
 190          /*----------------------------
 191            UART3 中断服务程序
 192            -----------------------------*/
 193          void Uart3() interrupt 17 using 1
 194          {
 195   1          if (S3CON & S3RI)
 196   1          {
 197   2              S3CON &= ~S3RI;         //清除S3RI位
 198   2              Uart3_Rec[uartRcvLen] = S3BUF;             //P0显示串口数据 
 199   2          uartRcvLen ++;
 200   2      
 201   2          }
 202   1          if (S3CON & S3TI)  //发送中断检测
 203   1          {
 204   2              S3CON &= ~S3TI;         //清除S3TI位
 205   2          }   
 206   1      
 207   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    646    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =     36      93
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
